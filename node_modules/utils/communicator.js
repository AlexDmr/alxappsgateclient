var WebSocket = require('websocket').client;
	var Communicator = function(serverAddr) {
		var self = this;
		
		this.L_messages   = [];
		this.D_subscribe  = {};
		this.D_fireforget = {};
		this.callId		  = 0;
		
		// cannot be called as a function...
		if (!(this instanceof Communicator)) {
			throw new TypeError("Communicator constructor cannot be called " +
					"as a function");
			}

		// if websockets are not supported, return
		if (typeof WebSocket === 'undefined') {
			 console.log("webSocket is not supported...");
			 return;
			} else {console.log("webSocket listening to " + serverAddr);}
		this.serverAddr = serverAddr;
	}

	/**
	 * Define the prototype of Communicator
	 */
	Communicator.prototype = {
		constructor: Communicator,
		subscribe: function(att, val, CB) {
			 this.callId++;
			 this.D_subscribe[this.callId] = {att:att, val:val, CB:CB};
			 console.log("D_subscribe:", this.D_subscribe);
			},
		initialize: function(argO) {
			var self = this;
			console.log( "Initialiazing " + this.serverAddr);
			// open a webSocket
			this.webSocket = new WebSocket();
			
			this.webSocket.on('connectFailed', function(error) {
					console.log('Connect Error: ' + error.toString());
				});
			// Connect
			this.webSocket.on( 'connect'
							 , function(connection) {
									 console.log("Connection established");
									 self.connection = connection;
									 connection.on('close', argO.onclose || function() {console.log("webSocket closed");});
									 connection.on('error', function(message) {console.error("Error from AppsGate:\n", message);});
									 connection.on('message', function(message) {self.handleMessage(message);});
									 for(var i=0; i<self.L_messages.length; i++) {self.sendMessage(self.L_messages[i].msg, self.L_messages[i].CB);}
									}
							 );
			this.webSocket.connect(this.serverAddr, null);
		},
		getServerAddr:function() {return this.serverAddr;},
		setServerAddr:function(serverAddr) {this.serverAddr = serverAddr;},
		reconnect:function() {
			// if there is already a connection, close it
			if (typeof this.webSocket !== "undefined") {
				this.webSocket.onclose = null;
				this.webSocket.close();
				delete this.webSocket;
			}
			
			// initialize the new connection
			this.initialize();
		},
		handleMessage:function(message) {
			var jsonMessage = JSON.parse( message.utf8Data );
			// console.log("received:\n", message.utf8Data );
			// Fire and forget ?
			var del = true;
			for(var D in {'D_fireforget':1, 'D_subscribe':1}) {
				for(var i in this[D]) {
					 // console.log("Received :", jsonMessage);
					 /*console.log( "Considering in ", D, " : ", this[D][i]
					            , "\nthis[D][i].val == jsonMessage[this[D][i].att\n"
								+ this[D][i].val + "=?=" + jsonMessage[this[D][i].att]
								);*/
					 if(  jsonMessage[this[D][i].att]
					   && ( this[D][i].val == null
					      ||this[D][i].val == jsonMessage[this[D][i].att]
					      ) ) {
						 this[D][i].CB(jsonMessage);
						 if(del) delete this[D][i];
						 return;
						}
					}
				 del = false;
				}
		},

		/**
		 * @method sendMessage
		 * Send a message to the backend. Global format of the protocol is:
		 * { "commandName": { "key": value } }
		 *
		 * @param commandName Command name to send with the message
		 * @param{string} messageData Data to send, typically an object
		 * @param targetType Parameter used by the server to route the message. 0: AbstractObject, 1: ApAM component
		 */
		sendMessage:function(message, CB) {
			//this.webSocket.send(JSON.stringify(message));
			if(this.connection) {
				 this.callId++;
				 message.callId = String(this.callId);
				 if(CB) {this.D_fireforget[this.callId] = {CB:CB, val:String(this.callId), att:'callId'};}
				 //console.log("sending", JSON.stringify(message), this.D_fireforget);
				 this.connection.send(JSON.stringify(message));
				} else {//console.log("\t=> ERROR : the connection is not ready");
					    this.L_messages.push( {msg:message, CB:CB} );
					   }
		},

		/**
		 * Close the websocket connection
		 */
		close:function() {this.webSocket.close();}
	};

// Export Communicator
exports.Communicator = Communicator;
